<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introduction to React</title>

		<meta name="description" content="Girl Develop It framework for easily creating beautiful presentations using HTML in GDI theme. Forked from Hakim El Hattab's reveal.js">
		<meta name="author" content="Eric Adams / GDI Buffalo">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="dist/css/reveal.css">
		<link rel="stylesheet" href="dist/css/default.css" id="theme">

		<!-- For syntax highlighting -->
		<!-- light editor --><link rel="stylesheet" href="dist/css/light.css">
		<!-- dark editor <link rel="stylesheet" href="dist/css/dark.css">-->
		<!-- <link rel="stylesheet" href="dist/css/zenburn.css"> -->

		<link rel="stylesheet" href="plugin/accessibility-helper/css/accessibility-helper.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!-- If use the PDF print sheet so students can print slides-->

		<link rel="stylesheet" href="dist/css/print/pdf.css" type="text/css" media="print">
		<link rel="icon" type="image/x-icon" href="favicon.ico" />
		<!--[if lt IE 9]>
		<script src="dist/js/html5shiv.js"></script>
		<![endif]-->

		<style>
			.reveal section .instructor-img {
				border-radius: 50%;
				display: block;
				height: 200px;
				object-fit: cover;
				margin: 0 auto 20px auto;
				width: 200px;
			}
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<section>
						<img src="dist/img/circle-gdi-logo.png" alt="GDI Logo" class="noborder" />
						<h1>Introduction to React</h1>
					</section>
					<section>
						<h2>Course Outline</h2>
						<ul>
							<li>Day 1: Introduction, Concepts, and Setup</li>
							<li>Day 2: Building Blocks of React</li>
							<li>Day 3: APIs &amp; Managing Application State</li>
							<li>Day 4: Best Practices &amp; Application Deployment</li>
						</ul>
					</section>
					<section>
						<h2>Course Goals</h2>
						<ul>
							<li>Understand React's Successes and Challenges (vs. other libs)</li>
							<li>Build a React Application from scratch, with custom components</li>
							<li>Consume and produce data within your applications</li>
							<li>Incorporate third-party components as needed for your applications</li>
							<li>Give you a desire to learn more, and expand your React knowledge!</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>First, a bit about your instructors.</h2>
					</section>
					<section>
						<h3>Eric Adams</h3>
						<img class="instructor-img" src="https://s3.amazonaws.com/gdi-buffalo-react/eric.png" />
						<ul>
							<li>Web Developer for 15+ years</li>
							<li>Senior Full-Stack Engineer @ ClearView Social</li>
							<li>Father of 3</li>
							<li>Musician</li>
						</ul>
						<aside class="notes">
							First, we'll tell you a bit about ourselves, for those of you who don't know us:
							(Insert points from the slide)
						</aside>
					</section>
					<section>
						<h3>Bill Boulden</h3>
						<img class="instructor-img" src="https://s3.amazonaws.com/gdi-buffalo-react/bill.png" />
						<ul>
							<li>CTO @ ClearView Social</li>
							<li>Former API Architect @ Delaware North Companies</li>
							<li>DJ Spruke</li>
							<li>Member of the Twitterati</li>
						</ul>
						<aside class="notes">
							(let Bill talk about himself)
						</aside>
					</section>
				</section>

				<section>
					<h2>What will we use in this course?</h2>
					<ul>
						<li class="fragment">git (to checkout code branches)</li>
						<li class="fragment">Node.JS and npm</li>
						<li class="fragment">React</li>
						<li class="fragment">create-react-app</li>
						<li class="fragment">React Bootstrap</li>
					</ul>
					<br><br>
					<h4 class="fragment">We're on our own for everything else!</h4>
				</section>

				<section>
					<h2>Course Structure</h2>
					<ul>
						<li>We'll start each day by checking out a code branch.</li>
						<li>We'll break up each day into two parts, with some Q&amp;A time between.</li>
						<li>Any questions during the class? Don't hesitate to ask!</li>
					</ul>
					<br><br>
					<p class="fragment">Now let's get started!</p>
					<aside class="notes">
						Over the next two weeks we're going to try and follow a schedule that will give time
						for both the instructional / theoretical parts of React, and the hands-on coding that'll
						get us using React to build an application.  We're going to build a simple application
						that lets a user upload images, create memes over them, and download/share those images.
						If you have any questions during any part of the course, feel free to ask!  We'll also
						break up each night into two parts, with the theory/explanation being part one and the hands-on
						part being part two.  Between each part we'll have Q&amp;A time as well.
					</aside>
				</section>

				<section>
					<h1>Day 1: Introduction,<br>Concepts, and Setup</h1>
					<center>
						<img src="https://s3.amazonaws.com/gdi-buffalo-react/getting-serious.jpg" />
					</center>
					<aside class="notes">
						Before we talk about react, let's talk briefly about the history of JavaScript frameworks.
						Since there's only 1 or 2 javascript frameworks this should be easy right?
					</aside>
				</section>

                <section>
					<section>
						<h1>JavaScript Frameworks</h1>
						<h2>(in 4 slides)</h2>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4222913/jquery.png" />
						</center>
						<h2>The jQuery Era</h2>
						<h3>Everything, Everywhere, All the Time</h3>
						<aside class="notes">
							The jQuery Era
							Everything, Everywhere, All the Time

							* Pros:
							* Very easy to create something quickly
							* Hides a lot of implementation details (animation, events)

							* Cons:
							* No organization to the code
							* Impossible to unit test
							* Difficult to read, and therefore difficult to debug
						</aside>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4222919/Screen_Shot_2017-10-13_at_10.43.57_PM.png" />
						</center>
						<h2>The Backbone Era</h2>
						<h3>Adding Structure to jQuery</h3>
						<aside class="notes">
							The Backbone Era
							Adding Structure to jQuery's Simplicity

							* Pros:
							* Easy to understand what the methods are doing
							* Easy to separate events, ajax, and DOM rendering
							* Still Hides a lot of implementation detials (animation, events)
							* Easier to modularize &amp; test
							* Easier to read

							* Cons:
							* Keeping the DOM in sync with your data
							* Communicating between modules
							* Tight coupling between modules that needed to communicate
						</aside>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4222930/Screen_Shot_2017-10-13_at_10.58.43_PM.png" />
						</center>
						<h2>The Angular Era</h2>
						<h3>Merging Data, Events, and Markup</h3>
						<aside class="notes">
							The Angular Era
							Merging Data, Events, and Markup Again

							* Pros:
							* Easy to connect events to the DOM
							* MVC approach to web development (started in backbone, but really evident here)
							* Still easy to separate events, ajax, and DOM rendering
							* Kept the DOM in sync with your data (just assign data to scope variables!)

							* Cons:
							* Communicating between modules
							* Testing is more difficult with a magical DOM
							* The learning curve!  Controllers, directives, scope, factories, and more
						</aside>
					</section>
					<section>
						<h2>JavaScript Today</h2>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4222940/js2016.png" />
						</center>
						<aside class="notes">
							This evolution of JavaScript frameworks has given us innovation, and a lot of options,
							enough that there has been something of an overload in what folks feel like they can
							handle to keep up with the rapid pace of innovation.  Also, with these frameworks
							came a lot of questions:

							* How do we separate modules for development?
							* How do we package applications for production?
							* How can we maintain cross-browser compatibility (remember jQuery? that's what it's all about!)
							* How can we utilize new features of the web platform now?

							A *lot* of package managers, task managers, compilers, and frameworks have tried to solve
							this, and two really stand out.  The babel project is pretty much the universally accepted
							transpiler for being able to use modern JavaScript syntax, also commonly known as ES6,
							in a way that is compatbile with all browsers.  Webpack has become the stand-out solution
							for managing modules in JavaScript, because it is able to directly hook into Babel and use
							its features.  It also is able to work with CSS modules, HTML or other types of templates,
							really plugins for most types of file formats exist in webpack to make them into modules.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4222948/jsx-highlight.png" />
						</center>
						<h2>The React Era</h2>
						<h3>Data, Events, and Markup become Components</h3>
					</section>
					<section>
						<h2>The Semantic Building Blocks</h2>
						<ul>
							<li>Extended HTML syntax</li>
							<li>Reusable Components</li>
							<li>Composed of Only Views</li>
							<li>Unique Build Pipeline</li>
						</ul>
						<aside class="notes">
							* Pros
							* Like Angular, we're back to writing _something_ that looks
							  more like HTML to represent our application
							* We do this by creating components, that are the building blocks
							  for our application (perhaps reference the polymer talk, or web components as an alternative)
							* We can hide the details of how we obtain data - in fact, react
							  doesn't care at all about *how* we get data
							* We don't have to think as much about how or when the DOM is rendered -
							  for the most part, React handles this

							* Cons
							* Unfamiliar syntax - JSX - JavaScript XML - incorporates javascript and markup
							  and abstract components together
							* Build pipeline to manage this syntax is unique.
							* You can build projects without ES6, but it's not fun and you can follow basically
							  none of the documentation - so the build pipeline is required
							* Managing data with react is different - there is a concept of "state" in components
							  that is different from the properties you set on a component
						</aside>
					</section>
					<section>
						<h2>The Advantages of React</h2>
						<ul>
							<li>Efficient Rendering using <a href="https://www.codecademy.com/articles/react-virtual-dom" target="_blank">Virtual DOM</a></li>
							<li>Able to run on the Server</li>
							<li>Reusable Components</li>
							<li>Automatic Event Delegation</li>
						</ul>
						<aside class="notes">
							Now, what are some unique advantages of using React for your project?

							* First, we have the idea of a Virtual DOM - without getting too much
							  in the weeds on how the Virtual DOM works, it is responsible for creating an
							  in-memory representation of your DOM that will only update the necessary bits
							  when data updates. Because rendering goes through the virtual DOM, an initial
							  render using react is a little bit slower, but updates are much faster.

							* Because the Virtual DOM is an in-memory representation of the DOM, and javascript
							  is used for updates, it can be run on the server, allow for "Universal JavaScript"
							  applications

							* Reusable Components - this idea isn't unique to react (its in polymer, angular,
							  and other frameworks) but using ES6 and module imports/exports by default in the
							  build pipeline, this is much easier to achieve

							* Events are automatically delegated within a component, meaning that events are
							  declared once and reused as the real DOM is updated

							All of these things allow you to program applications where performance and modularity
							are first-class concerns of the framework, rather than afterthoughts!
						</aside>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4229692/Screen_Shot_2017-10-16_at_3.53.56_PM.png" />
						</center>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4224357/scanlon.gif" />
						</center>
						<h3>So this is great for the web,</h3>
						<h3>but what else can it do?</h3>
					</section>
				</section>

				<section>
					<section>
						<h2>React Native</h2>
						<center>
							<img src="https://s3.amazonaws.com/media-p.slid.es/uploads/48886/images/4224331/Screen_Shot_2017-10-14_at_3.27.48_PM.png" />
						</center>
						<aside class="notes">
							Since components are reusable, and JSX is a declarative syntax that is both decoupled
							from the DOM and unique to react, what is "rendered" by JSX can be tailored for more than
							just the web.

							For example - React Native is a project that uses JSX to render native mobile applications. 
							Similar to the goals of NativeScript, but uses the react syntax that is familiar to React
							developers.

							There are a number of UI components already available for creating native mobile apps
							for both Android and iOS.  There are also a number of community-developed components,
							with more are being added.

							The upside of this all being, if you know React, you can easily learn the components
							to become an efficient mobile app developer!
						</aside>
					</section>
					<section>
						<h2>Some Companies Using<br> React Native</h2>
						<ul>
							<li>Facebook</li>
							<li>Instagram</li>
							<li>Airbnb</li>
							<li>Skype</li>
							<li>Walmart</li>
							<li>Bloomberg</li>
							<li>SoundCloud</li>
						</ul>
						<br><br>
						<a href="https://facebook.github.io/react-native/showcase.html">
							https://facebook.github.io/react-native/showcase.html
						</a>
					</section>
					<section>
						<h2>React &amp; Electron</h2>
						<a href="https://medium.freecodecamp.org/building-an-electron-application-with-create-react-app-97945861647c">
							https://medium.freecodecamp.org/building-an-electron-application-with-create-react-app-97945861647c
						</a>
						<aside class="notes">
							Electron is a completely different framework for creating desktop applications using JavaScript,
							in fact if you downloaded the GitHub Desktop application in advance of this course you
							are using an app built with Electron.  This article linked here is a great starter on using
							React to build Electron apps ... if anyone is interested in something like that its definitely
							beyond the scope of this course but this link is a good place to start.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Initial Setup</h1>
<pre><code>
	$ git clone https://github.com/adamsea/gdi-react-app.git
	$ ...cloning repo
	$ cd gdi-react-app
	$ npm install
	$ ...installing dependencies
	$ npm start

</code></pre>
						<aside class="notes">
							(Take a break here for questions)

							Now that we've gone over some of the history of JS development leading to react, and
							some of the reasons to use React, let's work on getting our development environments set
							up for this class.

							(instruct through downloading the repo, etc.)
						</aside>
					</section>
					<section>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/react-starter.png" />
						</center>
					</section>
					<section>
						<h2>create-react-app</h2>
						<blockquote cite="https://github.com/facebook/create-react-app#create-react-app-">
							Create React apps with no build configuration.
						</blockquote>
						<br>
						<br>
						<a href="https://github.com/facebook/create-react-app">https://github.com/facebook/create-react-app</a>
						<aside class="notes">
							While not essential to React development, I do want to take a moment to talk about
							create-react-app, as it is a BIG part of how react has continued to grow in adoption
							and get new developers involved.  Remember of course the "JavaScript Today" slide, and
							all of the options that are out there for building JS apps.  React is only a view layer,
							but it is a view layer that requires specific build tools.  Create-react-app has given
							developers a starter-kit for building react applications without having to mess with
							the configuration of build tools or build scripts which is great, because most developers
							really don't like getting involved with that stuff.
						</aside>
					</section>
					<section>
						<h2>Why use create-react-app?</h2>
						<ul>
							<li class="fragment">Managed Dependencies</li>
							<li class="fragment">Preconfigured Build Pipeline (both dev and production)</li>
							<li class="fragment">Developer-friendly Setup</li>
							<li class="fragment">PWA-friendly File Structure</li>
						</ul>
						<aside class="notes">
							Create-react-app is able to hide away the details of how it builds your app, and
							gives you a stable set of scripts you can run from the command line to develop, test,
							and deploy your applications.  It has build configurations for both development and
							production.  It also features things like automatic browser reloading (sometimes you'll
							hear that referred to as "hot reloading"), so it's very developer friendly.  It also
							will generate a file structure to build Progressive Web Applications - again, this is
							beyond the scope of this class, but having these tools in place is a great bonus feature
							of using create-react-app.

							(After this slide, open up vscode and explore the file structure.
							Then, we'll create a couple of basic components.)
						</aside>
					</section>
				</section>
				<section>
					<h2>Day 1: What We've Covered</h2>
					<ul>
						<li class="fragment">The evolution of JavaScript Frameworks</li>
						<li class="fragment">The Benefits of Using React</li>
						<li class="fragment">Other Projects Using React</li>
						<li class="fragment">Our Project Setup</li>
						<li class="fragment">Anatomy of a React Page</li>
					</ul>
				</section>
				<section>
					<h1>Day 2: Building Blocks of React</h1>
					<center>
						<img src="https://s3.amazonaws.com/gdi-buffalo-react/oprah.jpg" />
					</center>
				</section>
				<section>
					<h2>What We'll Cover</h2>
					<ul>
						<li class="fragment">Components</li>
						<li class="fragment">Props</li>
						<li class="fragment">State</li>
						<li class="fragment">Events</li>
						<li class="fragment">Children</li>
					</ul>
					<br><br>
					<h4 class="fragment">Let's Get Started!</h4>
				</section>
				<section>
					<section>
						<h2>Components</h2>
						<ul>
							<li>The building blocks of a React application</li>
							<li>Corresponds (usually) to an HTML Element on a page</li>
							<li>Contains a method to render markup</li>
							<li>Must be "mounted" using ReactDOM.render() with createElement()</li>
						</ul>
						<aside class="notes">
							Components are the building blocks of a React application. The markup to generate
							a component very closely resembles HTML, and most concepts of managing HTML through
							JavaScript extend to React Components.  A component is typically structured as a class,
							using the ES6 class syntax (example to follow).  The component class will contain a render
							method that is used to output a JSX virtual dom tree.  Going back to the virtual dom
							section from yesterday, this is what makes React fast - the fact that it keeps an in-memory
							representation of your components, that render actual HTML to the page.  All components are
							mounted to another component.  This typically occurs within the JSX when a component is rendered.
							However there is also a root component that must be rendered to the page, and this is typically
							attached to a single DOM node (a div) and the page structure proceeds to populate from there.
						</aside>
					</section>
					<section>
						<h2>Sample Component</h2>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/component.png" />
						</center>
					</section>
				</section>
				<section>
					<section>
						<h2>Props</h2>
						<ul>
							<li>Live in this.props within the scope of the component</li>
							<li>Are Read-Only within the scope of the component</li>
							<li>Are passed from the parent component to child components</li>
							<li>Act as a sort of "configuration" for components</li>
							<li>Syntax mimics that of HTML attributes</li>
						</ul>
						<aside class="notes">
							Props act as a way to pass key/value pairs to a component.  You can use them within a
							component through a property called this.props.  Each key passed in is available as a
							property in this.props, and you use those keys to access the values assigned to your
							component's props.  The are read-only, so you cannot change the value of a prop within
							a component.  However, if there is a change in a parent component, for instance, an API
							call or some other change that triggers a re-render, those modified values could be passed
							in as props to child components, which would update those components.  The best way to
							think about them is like HTML attributes.  They are used to configure a component to either
							appear or behave in a certain way, and if you make an update to that value, the underlying
							behavior changes.  (think like a "readonly" or "disabled" attribute on an HTML input or button)
						</aside>
					</section>
					<section>
						<h2>Sample Props</h2>
						<center>
							<img style="width: 45%; height: 230px; object-fit: cover;" src="https://s3.amazonaws.com/gdi-buffalo-react/props.png" />
							<img style="width: 45%; height: 230px; object-fit: cover;" src="https://s3.amazonaws.com/gdi-buffalo-react/props2.png" />
						</center>
					</section>
					<section>
						<h2>Reserved Properties</h2>
						<ul>
							<li>HTML Element attributes are mostly available - with two notable exceptions</li>
							<li>The HTML "class" attribute is called "className"</li>
							<li>The "key" property is reserved by React (more on this later)</li>
							<li>The HTML "style" attribute is called "styles"</li>
							<li>Inline Styles are passed as an object to "styles"</li>
						</ul>
						<aside class="notes">
							After reading these bullet points, just note that "className" specifically is gonna
							trip people up, especially if you copy code snippets to use in a react app
						</aside>
					</section>
					<section>
						<h2>Sample Styles Object</h2>
<pre class="javascript"><code>
	{
		color: "#333",
		backgroundColor: "#eee"
	}

</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>State</h2>
						<ul>
							<li>Live in this.state within the scope of the component</li>
							<li>Can be updated by calling setState() within a component</li>
							<li>State updates will trigger a re-render</li>
							<li>DOM updates are applied to the component and its descendants as needed</li>
							<li>React optimizes for minimum disruption to the DOM</li>
						</ul>
						<aside class="notes">
							Understanding state updates and how they affect a component is probably one
							of the trickiest, yet most important parts of building applications in React. The
							simplest answer, straight from the react docs, is that state changes always trigger
							a new render.  To update state for a component, you call this.setState, which takes
							two arguments - an object of the keys/values to update, and a callback that is fired
							after the state update is complete.

							React won't actually update a DOM representation of a component though,
							unless there is a change in props or state that actually affects a render.  Remember
							that the virtual dom is a representation of a components with their props and state,
							and react always manages rendering through its virtual dom.  Because of this, it's
							extremely important to understand that there may be unintended consequences when you
							mix libraries like jQuery with react.  jQuery might mutate the actual DOM, but since
							react doesn't track those mutations it will overwrite UI changes you make with jQuery.

							My best advice is to avoid using libraries like jQuery in react - if you google
							"awesome react" you'll see many components already build, a lot of which have similar
							if not identical functionality as jQuery plugins. (show search results here)
							If you must use a jQuery plugin, use it sparingly and only for things like animation
							or presentation - definitely do NOT use it for data manipulation
						</aside>
					</section>
					<section>
						<h2>Sample setState()</h2>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/state.png" />
						</center>
					</section>
				</section>
				<section>
					<section>
						<h2>Events</h2>
						<ul>
							<li>Event Handlers are passed as props to a component</li>
							<li>Syntax follows the form<br><br>
								<code>on&lt;Event&gt;={ this.doThing.bind(this) }</code><br><br></li>
							<li>React creates a SyntheticEvent object</li>
							<li>Properties like event.target can be used to read from the underlying element</li>
						</ul>
						<aside class="notes">
							Events in React can be passed as props to a component, as well as Native HTML elements
							when writing JSX.  If you write a component, you're responsible for handling an "event",
							and we'll see a sample of doing that when creating our components.  Events follow the
							naming format of their corresponding HTML attributes with onEvent, where "Event" can be
							"click" for buttons or links, "change" for input fields, "mouseover", and so on.  When
							you assign an event handler to an event property, you need to bind its "this" context to the
							component.  If you're not super-familiar with context in javascript that's ok, react
							handles a lot of that for you.  The main thing you need to remember is to either call
							"bind", passing this as the parameter, or set an anonymous function that calls your class
							method as the handler.  We'll see examples of both of those as we write our application.
							A SyntheticEvent object is created by React and passed to native HTML event handlers, which
							contain most of the properties you'd need to work with events.  For instance, you can use
							event.target.value to get the value of an input field, or event.target.files to get an
							array of files to upload.
						</aside>
					</section>
					<section>
						<h2>Sample Event Handler</h2>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/events.png" />
						</center>
					</section>
				</section>
				<section>
					<section>
						<h2>Children</h2>
						<ul>
							<li>this.props.children is a special prop that is analogous to innerHTML</li>
							<li>It is iterable, but you must iterate it using React.Children</li>
							<li>Elements between the start &amp; close tags of a JSX element are accessible as this.props.children</li>
						</ul>
						<aside class="notes">
							Children are a special prop that is used by React to denote child elements rendered
							within a component.  They can be accessed using this.props.children, and they can
							be iterated over like an array, but you must use the React.Children API to do that.
							Basically if you nest elements within a JSX tag for a component you create, those
							elements would be rendered using this.props.children.  In my own experience, I haven't
							used this.props.children a lot, but once you get going with react your experience may differ.
							I'd say it more important to plugin authors, or for creating very abstract/reusable components.
							(then show sample on the next slide and explain it)
						</aside>
					</section>
					<section>
						<h2>Sample Children w/Iteration</h2>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/children.png" />
						</center>
					</section>
				</section>
				<section>
					<section>
						<h2>Keys</h2>
						<ul>
							<li>The "key" property is used to uniquely identify a child when there are sibling elements</li>
							<li>React uses "key" to differentiate components in a list</li>
							<li>If you are missing "key", you will lose performance, and potentially component updates!</li>
							<li>Typically correspond to a uuid, database id, or loop index as a fallback</li>
							<li>You will be warned in the console if this is missing :)</li>
						</ul>
						<aside class="notes">
							Keys are a reserved property in JSX that are used internally by react.  They are used
							to differentiate child components among their sibling elements, which is very useful
							for updating lists of items.  If you are missing a key on an item with siblings, you
							will potentially lose performance benefits of React rendering, as well as possible
							updates to a particular item in a list.  It's hard to forget this though, because react
							gives you a warning for each child missing a key prop.  In my experience a key will typically
							be a database row id for items returned from an api, or a uuid that you generate.  It can
							even be a loop index if you have nothing else to fallback on.
						</aside>
					</section>
					<section>
						<h2>Sample Keys</h2>
						<center>
							<img src="https://s3.amazonaws.com/gdi-buffalo-react/props2.png" />
						</center>
					</section>
				</section>
				<section>
					<h2>Questions?</h2>
					<div class="fragment">
						<h4>Let's create some components!</h4>
						<center>
							<img src="https://media.giphy.com/media/BwOU6uH7afefu/giphy.gif" />
						</center>
					</div>
				</section>
			</div>
			<footer>
				<div class="copyright">
					Introduction to React -- GDI Buffalo --
					<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>
				</div>
			</footer>
		</div>


		<script src="dist/js/head.min.js"></script>
		<script src="dist/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'dist/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/accessibility-helper/js/accessibility-helper.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
